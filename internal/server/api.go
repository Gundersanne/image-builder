// Package server provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi"
	"net/http"
	"strings"
)

// AWSUploadRequestOptions defines model for AWSUploadRequestOptions.
type AWSUploadRequestOptions struct {
	Ec2    AWSUploadRequestOptionsEc2 `json:"ec2"`
	Region string                     `json:"region"`
	S3     AWSUploadRequestOptionsS3  `json:"s3"`
}

// AWSUploadRequestOptionsEc2 defines model for AWSUploadRequestOptionsEc2.
type AWSUploadRequestOptionsEc2 struct {
	AccessKeyId     string `json:"access_key_id"`
	SecretAccessKey string `json:"secret_access_key"`
}

// AWSUploadRequestOptionsS3 defines model for AWSUploadRequestOptionsS3.
type AWSUploadRequestOptionsS3 struct {
	AccessKeyId     string `json:"access_key_id"`
	Bucket          string `json:"bucket"`
	SecretAccessKey string `json:"secret_access_key"`
}

// ComposeRequest defines model for ComposeRequest.
type ComposeRequest struct {
	Customizations *Customizations `json:"customizations,omitempty"`
	Distribution   string          `json:"distribution"`
	ImageRequests  []ImageRequest  `json:"image_requests"`
}

// ComposeResponse defines model for ComposeResponse.
type ComposeResponse struct {
	Id string `json:"id"`
}

// ComposeStatus defines model for ComposeStatus.
type ComposeStatus struct {
	Status string `json:"status"`
}

// Customizations defines model for Customizations.
type Customizations struct {
	Subscription *Subscription `json:"subscription,omitempty"`
}

// DistributionItem defines model for DistributionItem.
type DistributionItem struct {
	Description string `json:"description"`
	Name        string `json:"name"`
}

// Distributions defines model for Distributions.
type Distributions []DistributionItem

// ImageRequest defines model for ImageRequest.
type ImageRequest struct {
	Architecture   string           `json:"architecture"`
	ImageType      string           `json:"image_type"`
	UploadRequests *[]UploadRequest `json:"upload_requests,omitempty"`
}

// Subscription defines model for Subscription.
type Subscription struct {
	ActivationKey string `json:"activation-key"`
	BaseUrl       string `json:"base-url"`
	Insights      bool   `json:"insights"`
	Organization  int    `json:"organization"`
	ServerUrl     string `json:"server-url"`
}

// UploadRequest defines model for UploadRequest.
type UploadRequest struct {
	Options AWSUploadRequestOptions `json:"options"`
	Type    string                  `json:"type"`
}

// Version defines model for Version.
type Version struct {
	Version string `json:"version"`
}

// ComposeImageJSONBody defines parameters for ComposeImage.
type ComposeImageJSONBody ComposeRequest

// ComposeImageRequestBody defines body for ComposeImage for application/json ContentType.
type ComposeImageJSONRequestBody ComposeImageJSONBody

type ServerInterface interface {
	// compose image (POST /compose)
	ComposeImage(w http.ResponseWriter, r *http.Request)
	// get status of an image compose (GET /compose/{composeId})
	GetComposeStatus(w http.ResponseWriter, r *http.Request)
	// get the available distributions (GET /distributions)
	GetDistributions(w http.ResponseWriter, r *http.Request)
	// get the openapi json specification (GET /openapi.json)
	GetOpenapiJson(w http.ResponseWriter, r *http.Request)
	// get the service version (GET /version)
	GetVersion(w http.ResponseWriter, r *http.Request)
}

// ComposeImage operation middleware
func ComposeImageCtx(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

// GetComposeStatus operation middleware
func GetComposeStatusCtx(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		var err error

		// ------------- Path parameter "composeId" -------------
		var composeId string

		err = runtime.BindStyledParameter("simple", false, "composeId", chi.URLParam(r, "composeId"), &composeId)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter composeId: %s", err), http.StatusBadRequest)
			return
		}

		ctx = context.WithValue(ctx, "composeId", composeId)

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

// GetDistributions operation middleware
func GetDistributionsCtx(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

// GetOpenapiJson operation middleware
func GetOpenapiJsonCtx(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

// GetVersion operation middleware
func GetVersionCtx(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerFromMux(si, chi.NewRouter())
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	r.Group(func(r chi.Router) {
		r.Use(ComposeImageCtx)
		r.Post("/compose", si.ComposeImage)
	})
	r.Group(func(r chi.Router) {
		r.Use(GetComposeStatusCtx)
		r.Get("/compose/{composeId}", si.GetComposeStatus)
	})
	r.Group(func(r chi.Router) {
		r.Use(GetDistributionsCtx)
		r.Get("/distributions", si.GetDistributions)
	})
	r.Group(func(r chi.Router) {
		r.Use(GetOpenapiJsonCtx)
		r.Get("/openapi.json", si.GetOpenapiJson)
	})
	r.Group(func(r chi.Router) {
		r.Use(GetVersionCtx)
		r.Get("/version", si.GetVersion)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/9RWUW/bNhD+KwS3hw2QJdcp0MJvWequbtKkiLGuRREEtHi22EqiQp7ieIH/+yCKkkWJ",
	"cdJheehTHJG8++77vjvynsYyK2QOOWo6vac6TiBj5ufx34u/ilQyfgk3JWi8KFDI3CwVShagUID5D+JJ",
	"9edXBSs6pb9E+4iRDRc9EGsWT+guoArWQuYm1B3LihTolEI52oDG0QsaUNwW1SeNSuTr6oA++o8JF0d0",
	"ZxLelEIBp9OvTXITNDC1XLUZ5fIbxFhlPFDAgA8Wx6D19XfYXgvuVnV8Oj+eXyzeXrw5P381+3z84ePZ",
	"zFsgxArweh/JDbN5z1L1+WbDxc2Gv519mEenr27EhkfLj3eXK3HyxYY+nX2hAV1JlTGkU1owrTdS8WHG",
	"HiduBT44P8DR4uhZKFqW8XdA92y2HdnPPyOnbU0+ck8qj2uw1A4ZjUuNMhP/sLZJD7XHibt7F1AuKtzL",
	"EgedqBJIR699jIqMreFa1ZBMToGQPZp8Xh1rCtm1cZlSbDugzcE1SHmQKV3IXMOQqtpxh9USnF7tYy2Q",
	"YemZfLr9fjia3WciDnTqhSyXOlaiaHQ4ROSiu3e383DxpsPeHCEb5uPgpNvLfgmcvGNIZjmCKpTQQM5E",
	"Xt6R3y7fzc5+J6/Dic8TOcvgaf7pcWQOBg6eq0cqerrlBjwMbBdQx5bDiaXiRCDEWCrwCN44s/7sWS7N",
	"ZPzxZnEm6qPd4qB0MFXeW/S81Z/JKG6NLUeD4ZhtR/W8GtWD6gnjL6BLpmFUqtQNlSAW0yiKeR4q4AnD",
	"MJZZ1I1ZHfFNm1yLdVJT14ZDVUK7dyllCiyvNku1ZrntMufAZPxyfDR52Z4ROcIaVH1BqFtQQ8TdlgxV",
	"orMO8Edt7QAJ+iQ7STuMdar1NYFrioGSsnjSJfDQA6812T2FvMyMrzZdIA+UalaDNrsP+CdQ2mu+2/3C",
	"4STNxqvdznhiJQdTjC5A3YoYCCYMiYKUbTUxrUCWpUg5aZswoKmIwV4S9eSixwWLEyCTcEwDY8Xasnoa",
	"RZvNJmRmOZRqHdmzOjqbn8zOF7PRJByHCWapYVCgMc+FNjlHItfI0hQU0TU6GuyLpi+MZwvIWSHolB6F",
	"47B6+BYME0NPLZ+9zGStuVuz3VDXaVQAZXw253Ta3GNzu2gJ+ENy0+exzBFyE5QVRSpiczD6pmtBar88",
	"+qRwHyhGHhciB2Qi1USurBooyRKIRc5pV+iqr43y9SVuSJiMx/8/WvtI8MBtGE2YJhqZQuDGjbrMMqa2",
	"A86rtUan6N7+mPNdBWUNHsnqV0FFB8stI43Mff3+BHSfIpU3FMsAQWk6/doPPedV2AafTYSSrM3TWORm",
	"cmNCm/uatnAHKgQdRvutefX8Ctl6D+ijmx1dadaA5AC/Rivef0pYlQbUu2+OZ6zZTeSpmZFUaDQl3TKR",
	"smUKhPcO9WnABA7ujuzcCRusD9FwUe97r81N5iPBBasAS5VrgonQhMu4zCqC/AAtBlJhILqAWKwshdUN",
	"y9aVyWkGyKrBH9Coc194e6uJa4ctafZ7GutTu/RsujYpvIr2IfoJGu7a7f4NAAD//xgDYpm9EQAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
